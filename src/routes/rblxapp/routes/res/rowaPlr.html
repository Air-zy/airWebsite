<!doctype html>
<html lang="en">

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>DisplayName @Username</title>
  <style>
    :root {
      --bg: #000000;
      --card: #0f1720;
      --muted: #9aa6b2;
      --accent: #fab760;
      --glass: rgba(255, 255, 255, 0.03)
    }

    html,
    body {
      margin: 0;
      background: linear-gradient(342deg, var(--bg), #2a2a2a);
      color: #e6eef6;
      font-family: Inter, system-ui, Segoe UI, Roboto, Arial
    }

    .wrap {
      max-width: 1200px;
      margin: 36px auto;
      padding: 18px
    }

    .card {
      background: #00000030;
      border-radius: 12px;
      padding: 30px;
      border: 1px solid rgba(255, 255, 255, 0.06)
    }

    header {
      display: flex;
      align-items: center;
      justify-content: space-between
    }

    .playerHead {
      display: flex;
      align-items: center;
      gap: 12px
    }

    .avatar {
      width: 64px;
      height: 64px;
      flex: 0 0 64px;
      display: flex;
      align-items: center;
      justify-content: center
    }

    .avatar img {
      width: 64px;
      height: 64px;
      border-radius: 999px;
      object-fit: cover;
      display: block
    }

    .avatar-fallback {
      width: 64px;
      height: 64px;
      border-radius: 999px;
      background: linear-gradient(135deg, #0b1220, #111419);
      display: flex;
      align-items: center;
      justify-content: center;
      font-weight: 700;
      font-size: 20px;
      color: var(--accent);
      border: 2px solid rgba(255, 255, 255, 0.06)
    }

    h1 {
      font-size: 20px;
      margin: 0;
      color: #fff;
      line-height: 1
    }

    h1 a {
      color: inherit;
      text-decoration: none
    }

    .sub {
      color: var(--muted);
      font-size: 13px
    }

    .stats {
      display: flex;
      gap: 30px;
      flex-wrap: wrap;
      justify-content: center;
      margin-right: 10%
    }

    .stat {
      min-width: 10px;
      text-align: center
    }

    .label {
      color: var(--muted);
      font-size: 12px
    }

    .value {
      font-size: 16px;
      color: #fff
    }

    .big {
      font-size: 28px;
      color: var(--accent);
      font-weight: 800
    }

    main {
      margin-top: 20px;
      display: flex;
      gap: 14px;
      flex-direction: column;
    }

    details {
      background: rgba(255, 255, 255, 0.02);
      padding: 10px;
      border-radius: 8px;
      color: var(--muted)
    }

    summary {
      cursor: pointer;
      font-weight: 400;
      color: #fff
    }

    .slots {
      display: flex;
      flex-direction: column;
      gap: 8px
    }

    .slot {
      padding: 10px;
      border-radius: 8px;
      background: linear-gradient(180deg, rgba(255, 255, 255, 0.01), rgba(255, 255, 255, 0.005));
      border: 1px solid rgba(255, 255, 255, 0.02)
    }

    .slot h3 {
      margin: 0 0 6px 0;
      font-size: 14px
    }

    .row {
      display: flex;
      gap: 40px;
      flex-wrap: wrap
    }

    .kv {
      min-width: 10px;
      color: var(--muted);
      font-size: 13px
    }

    .sm {
      font-size: 12px;
      color: var(--muted)
    }

    .error {
      color: #ffa3a3
    }

    #touchCanvas {
      width: 100%;
      height: 220px;
      border-radius: 8px;
      background: linear-gradient(180deg, rgba(255, 255, 255, 0.01), transparent);
      display: block
    }

    #touchWrap {
      padding: 8px;
      border-radius: 8px;
      background: rgba(255, 255, 255, 0.01);
      margin-top: 8px
    }

    /* new plrStats styling */
    .combat {
      padding: 12px;
      margin-top: 8px;
      margin-bottom: 12px;
      border-radius: 8px;
      background: rgba(255,255,255,0.02);
      border: 1px solid rgba(255,255,255,0.02);
    }

    .combat-grid {
      display: grid;
      grid-template-columns: repeat(4, 1fr);
      gap: 8px 12px;
    }

    .combat-item {
      padding: 8px;
      border-radius: 6px;
      background: linear-gradient(180deg, rgba(255,255,255,0.005), transparent);
      display: flex;
      flex-direction: column;
      align-items: center;
    }

    .combat-item .k { color: var(--muted); font-size: 12px }
    .combat-item .v { font-size:12px }

    .small-p {
      font-size: .75rem;
      line-height: 1rem;
      color: #585858;
      display: flex;
      justify-content: center;
      padding: 20px;
    }

    @media(max-width:880px) {
      .combat-grid { grid-template-columns: 1fr }
    }

    @media(max-width:560px) {
      .avatar {
        width: 48px;
        height: 48px;
        flex: 0 0 48px
      }

      .avatar img,
      .avatar-fallback {
        width: 48px;
        height: 48px
      }
    }
  </style>
</head>

<body>
  <div class="wrap">
    <div class="card">
      <header>
        <div class="playerHead">
          <div class="avatar" id="avatarContainer">
            <!-- either the img or fallback DIV will be inserted here by JS -->
          </div>

          <div>
            <h1 id="playerId"><a id="playerLink" href="#" target="_blank" rel="noopener">—</a></h1>
            <div class="sub" id="sub">Fetching /api/rowa/{id}</div>
          </div>
        </div>

        <div class="stats" id="stats"></div>
      </header>

      <main>
        <section>
          <div class="sm" style="margin-bottom:6px">Combat Stats</div>
          <div id="plrStatsWrap" class="combat">
            <div id="plrStatsGrid" class="combat-grid">
              <div class="sm">Loading...</div>
            </div>
          </div>

          <div class="sm" style="margin-bottom:6px">Slots</div>
          <div class="slots" id="slots">
            <div class="sm">Loading...</div>
          </div>
        </section>

        <aside>
          <div style="margin-bottom:12px">
            <div class="sm">Meta</div>
            <div style="padding:12px;margin-top:8px;border-radius:8px;background:rgba(255,255,255,0.02);">
              <div class="sm" id="firstseen" >First seen</div>
              <div class="sm" id="lastseen"  >Last seen</div>
              <div class="sm" id="playtime"  >Total playtime -</div>
              <div class="sm" >Followed IDs</div>
              <div id="followedWrap" style="padding-top:6px">
                <div id="followedList" class="sm">-</div>
              </div>
            </div>
          </div>

          <details>
            <summary>Keybinds <span id="kcount" class="sm"></span></summary>
            <pre id="kbPre" style="margin-top:8px;white-space:pre-wrap;color:var(--muted)"></pre>
          </details>

          <details style="margin-top:10px">
            <summary>Touch Data <span id="tcount" class="sm"></span></summary>

            <div id="touchWrap">
              <!-- canvas visualization (drawn if data exists) -->
              <canvas id="touchCanvas" aria-label="Touch visualization"></canvas>

              <!-- raw JSON fallback / debug -->
              <pre id="touchPre" style="margin-top:8px;white-space:pre-wrap;color:var(--muted)"></pre>
            </div>
          </details>
        </aside>
      </main>
    </div>
  </div>
  <p class="small-p">© 2024 Airzy Turqueza.</p>
  <script>
    (async function () {
      const segments = location.pathname.split('/').filter(Boolean);
      const id = segments.at(-1) || 'unknown';

      const link = document.getElementById('playerLink');
      const sub = document.getElementById('sub');
      const stats = document.getElementById('stats');
      const slots = document.getElementById('slots');
      const followedList = document.getElementById('followedList');
      const kb = document.getElementById('kbPre');
      const touch = document.getElementById('touchPre');
      const kc = document.getElementById('kcount');
      const tc = document.getElementById('tcount');
      const canvas = document.getElementById('touchCanvas');
      const avatarContainer = document.getElementById('avatarContainer');
      const plrStatsGrid = document.getElementById('plrStatsGrid');

      const esc = s => String(s).replaceAll('&', '&amp;').replaceAll('<', '&lt;')
        .replaceAll('>', '&gt;').replaceAll('"', '&quot;')
        .replaceAll("'", '&#39;');

      // DisplayName + Username from <title>
      const t = document.title.trim();
      let display = id;
      const match = t.match(/^(.+?)\s*@(.+)$/);
      if (match) {
        const [_, d, n] = match;
        display = `${esc(d)} (@${esc(n)})`;
      }

      // avatar: read meta tags (server injects og:image / twitter:image / link rel=image_src)
      const ogImg = document.querySelector('meta[property="og:image"]')?.content
        || document.querySelector('meta[name="twitter:image"]')?.content
        || document.querySelector('link[rel="image_src"]')?.href
        || null;
      const ogAlt = document.querySelector('meta[property="og:image:alt"]')?.content || display;

      // build avatar element(s)
      avatarContainer.innerHTML = ''; // clear
      if (ogImg) {
        const img = document.createElement('img');
        img.src = ogImg;
        img.alt = ogAlt;
        img.loading = 'lazy';
        img.decoding = 'async';
        img.onerror = function () {
          // fallback to initials if the image fails to load
          avatarContainer.innerHTML = '';
          const fb = document.createElement('div');
          fb.className = 'avatar-fallback';
          fb.textContent = (display && display[0]) ? display[0].toUpperCase() : '?';
          avatarContainer.appendChild(fb);
        };
        avatarContainer.appendChild(img);
      } else {
        const fb = document.createElement('div');
        fb.className = 'avatar-fallback';
        fb.textContent = (display && display[0]) ? display[0].toUpperCase() : '?';
        avatarContainer.appendChild(fb);
      }

      link.href = `https://www.roblox.com/users/${encodeURIComponent(id)}/profile`;
      link.textContent = display;
      sub.textContent = '/rowa/' + id;

      const fmtDate = s => {
        if (!s) return '—';
        const n = Number(s);
        if (isNaN(n)) return '—';

        return new Date(n * 1000).toLocaleString('en-US', {
          month: 'short',
          day: 'numeric',
          year: 'numeric',
          hour: 'numeric',
          minute: '2-digit',
          hour12: true
        });
      };

      const fmtPlay = sec => {
        if (sec == null) return '—';

        const days = Math.floor(sec / 86400);
        const hours = Math.floor((sec % 86400) / 3600);
        const minutes = Math.floor((sec % 3600) / 60);

        if (days > 0) {
          return `${days}d ${hours}h ${minutes}m`;
        }

        return `${hours}h ${minutes}m`;
      };


      // Action names for keybindData
      const keybindNames = {
        1: "sprint", 2: "parry", 3: "dash", 4: "feint", 5: "slide",
        6: "heavy", 7: "light", 8: "ability",
        9: "hotbar1", 10: "hotbar2", 11: "hotbar3", 12: "hotbar4",
        13: "hotbar5", 14: "hotbar6", 15: "hotbar7", 16: "hotbar8",
        17: "hotbar9", 18: "hotbar10"
      };

      // Friendly names for special/large keycodes (optional)
      const specialKeyNames = {
        306: "LeftCntrl",
        305: "RightCntrl",
        307: "RightAlt",
        308: "LeftAlt",
        0: "M1",
        1: "M2",
        2: "M3",
        3: "M4",
        4: "M5",
        5: "M6",
        13: "Enter",
        27: "Escape",
        32: "Space",
        37: "ArrowLeft",
        38: "ArrowUp",
        39: "ArrowRight",
        40: "ArrowDown",
      };

      function prettyKey(code) {
        if (code === -1) return "None";
        if (code == null) return "None";
        if (specialKeyNames[code]) return `${specialKeyNames[code]}`;
        if (code >= 32 && code <= 126) {
          const ch = String.fromCharCode(code);
          if (/[a-zA-Z0-9]/.test(ch)) return `${ch.toUpperCase()}`;
          return `${ch} (${code})`;
        }
        return `Key(${code})`;
      }

      function clearCanvas() {
        const ctx = canvas.getContext('2d');
        ctx.save();
        ctx.setTransform(1, 0, 0, 1, 0, 0);
        ctx.clearRect(0, 0, 0, canvas.width, canvas.height);
        ctx.restore();
      }

      function renderTouch(tdata) {
        // tdata expected: [[x,y,size], ...]
        const ctx = canvas.getContext('2d');
        // resize canvas for crispness (use client size + DPR)
        const DPR = window.devicePixelRatio || 1;
        const cw = Math.max(200, canvas.clientWidth || 300);
        const ch = Math.max(120, canvas.clientHeight || 220);
        canvas.style.height = ch + 'px';
        canvas.width = Math.round(cw * DPR);
        canvas.height = Math.round(ch * DPR);
        ctx.scale(DPR, DPR);
        ctx.clearRect(0, 0, cw, ch);

        if (!Array.isArray(tdata) || tdata.length === 0) {
          // draw "no data" message
          ctx.font = '13px system-ui, Inter, Arial';
          ctx.fillStyle = 'rgba(255,255,255,0.06)';
          ctx.fillRect(0, 0, cw, ch);
          ctx.fillStyle = 'var(--muted)';
          ctx.textAlign = 'center';
          ctx.fillText('No touch data to visualize', cw / 2, ch / 2);
          return;
        }

        // filter valid points: ensure numbers
        const pts = tdata.map(p => [Number(p[0]), Number(p[1]), Number(p[2])]).filter(p => !Number.isNaN(p[0]) && !Number.isNaN(p[1]));
        if (pts.length === 0) {
          ctx.fillStyle = 'var(--muted)';
          ctx.textAlign = 'center';
          ctx.fillText('No valid touch points', cw / 2, ch / 2);
          return;
        }

        // compute bounds
        let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
        pts.forEach(p => {
          if (p[0] < minX) minX = p[0];
          if (p[0] > maxX) maxX = p[0];
          if (p[1] < minY) minY = p[1];
          if (p[1] > maxY) maxY = p[1];
        });

        // if degenerate, expand a little to avoid zero scale
        if (minX === maxX) { minX -= 1; maxX += 1; }
        if (minY === maxY) { minY -= 1; maxY += 1; }

        // padding (pixels)
        const pad = Math.min(40, Math.min(cw, ch) * 0.12);

        const usableW = cw - pad * 2;
        const usableH = ch - pad * 2;

        const dataW = maxX - minX;
        const dataH = maxY - minY;

        const scaleX = usableW / dataW;
        const scaleY = usableH / dataH;
        // keep aspect: choose the smaller scale so everything fits
        const scale = Math.min(scaleX, scaleY);

        // center the data in the usable area
        const drawnW = dataW * scale;
        const drawnH = dataH * scale;
        const offsetX = pad + ((usableW - drawnW) / 2) - minX * scale;
        const offsetY = pad + ((usableH - drawnH) / 2) - minY * scale;

        // background
        ctx.fillStyle = 'rgba(255,255,255,0.01)';
        ctx.fillRect(0, 0, cw, ch);

        // draw bounding box (input bounds)
        ctx.save();
        ctx.strokeStyle = 'rgba(255,255,255,0.12)';
        ctx.setLineDash([5, 4]);
        ctx.lineWidth = 1;
        ctx.strokeRect(offsetX, offsetY, drawnW, drawnH);
        ctx.restore();

        // draw points
        pts.forEach((p, i) => {
          const x = offsetX + p[0] * scale;
          const y = offsetY + p[1] * scale;
          const radius = Math.max(2, (p[2] || 8) * 0.5 * scale); // size interpreted as diameter-ish; scale it
          // filled translucent circle
          ctx.beginPath();
          ctx.fillStyle = 'rgba(96,165,250,0.12)'; // semi-transparent accent
          ctx.arc(x, y, radius, 0, Math.PI * 2);
          ctx.fill();
          // outline
          ctx.lineWidth = 1.2;
          ctx.strokeStyle = 'rgba(96,165,250,0.9)';
          ctx.stroke();

          // index label (small)
          ctx.font = '10px system-ui, Inter, Arial';
          ctx.fillStyle = 'rgba(255,255,255,0.9)';
          ctx.textAlign = 'center';
          ctx.fillText(String(i + 1), x, y - radius - 6);
        });

        // draw min/max label text
        ctx.font = '11px system-ui, Inter, Arial';
        ctx.fillStyle = 'rgba(255,255,255,0.85)';
        ctx.textAlign = 'left';
        ctx.fillText(`x: ${minX} → ${maxX}`, 8, ch - 28);
        ctx.fillText(`y: ${minY} → ${maxY}`, 8, ch - 12);
      }

      try {
        const res = await fetch('/api/rowa/' + encodeURIComponent(id));
        if (!res.ok) {
          slots.innerHTML = '<div class="sm error">Failed to load</div>';
          sub.textContent = 'Error: ' + res.status;
          return;
        }
        const plrData = await res.json();

        // Stats
        const wins = +plrData.wins || 0
        const loss = +plrData.loss || 0
        const total = wins + loss;
        const winrate = total ? (wins / total * 100).toFixed(2) + '%' : '—';
        const elo = plrData.elo ?? '—';
        const seed = plrData.seed ?? '—';
        const stat = (l, v, b) => `<div class="stat"><div class="label">${l}</div><div class="${b ? 'big' : 'value'}">${v}</div></div>`;

        let statInnerHTML = stat('WON', wins)
        + stat('LOST', loss)
        + stat('WINRATE', winrate)
        + stat('ELO', esc(elo))
        //+ stat('SEED', esc(seed));

        // Meta
        const firstseen = document.getElementById('firstseen');
        const lastseen = document.getElementById('lastseen');
              const play = document.getElementById('playtime');

        const plrMeta = plrData.meta || {};
        const firstJoined = plrMeta.first ? fmtDate(plrMeta.first) : '-';
        const lastPlayed = plrMeta.last ? fmtDate(plrMeta.last) : '-';
        firstseen.textContent = 'firstSeen: ' + firstJoined;
        lastseen.textContent  = 'lastSeen: ' + lastPlayed;
        play.textContent      = 'plrSeed: ' + esc(seed)//'Total playtime - ' + fmtPlay(plrMeta.totalPlaytime || 0);

        // followedIds display (robust: accepts array, object or single number)
        try {
          const raw = plrMeta.followedIds;
          if (!raw) {
            followedList.textContent = '-';
          } else {
            let arr = [];
            if (Array.isArray(raw)) {
              arr = raw.map(Number).filter(n => !Number.isNaN(n));
            } else if (typeof raw === 'object') {
              // common shape: { "123": true, "456": true } OR { "0":123, "1":456 }
              const keysAsNums = Object.keys(raw).map(k => Number(k)).filter(n => !Number.isNaN(n));
              const valsAsNums = Object.values(raw).map(v => Number(v)).filter(n => !Number.isNaN(n));
              arr = Array.from(new Set(keysAsNums.concat(valsAsNums)));
            } else if (typeof raw === 'number' || (typeof raw === 'string' && /^\d+$/.test(raw))) {
              const n = Number(raw);
              if (!Number.isNaN(n)) arr = [n];
            }

            if (!arr || arr.length === 0) {
              followedList.textContent = '—';
            } else {
              // limit how many we render for UI clarity
              const maxShow = 10;
              const show = arr.slice(0, maxShow);
              followedList.innerHTML = show.map(iid => `
                <a href="https://www.roblox.com/users/${encodeURIComponent(iid)}/profile" target="_blank" rel="noopener">${esc(iid)}</a>
              `).join(', ');
              if (arr.length > maxShow) {
                followedList.innerHTML += ` and ${arr.length - maxShow} more`;
              }
            }
          }
        } catch (e) {
          followedList.textContent = '—';
        }

        if (plrMeta.totalPlaytime) {
          statInnerHTML += stat('PLAYTIME', fmtPlay(plrMeta.totalPlaytime || 0));
        }

        if (plrMeta.clientInfo) {
          function emojiToTwemojiURL(emoji) {
            // Convert each character to lowercase hex
            const codePoints = Array.from(emoji).map(c => c.codePointAt(0).toString(16)).join('-');
            return `https://twemoji.maxcdn.com/v/latest/72x72/${codePoints}.png`;
          }

            let info = esc(plrMeta.clientInfo); // escape text

            // Match all flag emojis: two regional indicators (U+1F1E6–U+1F1FF)
            const flagRegex = /[\u{1F1E6}-\u{1F1FF}]{2}/gu;

            info = info.replace(flagRegex, match => {
              const url = emojiToTwemojiURL(match);
              return `<img src="${url}" alt="${match}" style="width:18px;height:18px;vertical-align:middle;margin-left:2px;">`;
            });

            statInnerHTML += stat('CLIENT INFO', info);
        }


        stats.innerHTML = statInnerHTML

        // Keybinds — now pretty-printed with key names
        const k = plrData.keybindData || [];
        kc.textContent = '(' + k.length + ')';
        let out = "";
        for (let i = 0; i < k.length; i++) {
          const name = keybindNames[i + 1] || `action${i + 1}`;
          const pair = k[i] || [];
          const b1 = (pair.length > 0) ? pair[0] : -1;
          const b2 = (pair.length > 1) ? pair[1] : -1;
          out += `${name}: ${prettyKey(b1)}, ${prettyKey(b2)}\n`;
        }
        kb.textContent = out;

        // Touch Data
        const td = plrData.touchData || [];
        touch.textContent = JSON.stringify(td, null, 2);
        tc.textContent = '(' + td.length + ')';
        // render visualization (if present)
        try {
          renderTouch(td);
        } catch (err) {
          console.error('renderTouch failed', err);
          // fallback: clear canvas and print error
          clearCanvas();
          const ctx = canvas.getContext('2d');
          ctx.font = '13px system-ui, Inter, Arial';
          ctx.fillStyle = 'var(--muted)';
          ctx.textAlign = 'center';
          ctx.fillText('Visualization error', canvas.clientWidth / 2, canvas.clientHeight / 2);
        }

        // Slots
        slots.innerHTML = '';
        (plrData.slots || []).forEach((s, i) => {
          const name = esc(s[0] || `Slot ${i + 1}`);
          const sSeed = esc(s[1] ?? '—');
          const first = fmtDate(s[3]?.first);
          const sElo = esc(s[5] ?? '—'), sW = s[6] ?? 0, sL = s[7] ?? 0;
          slots.innerHTML += `
        <div class="slot">
          <h3>${name}</h3>
          <div class="row">
            <div class="kv"><div class="sm">SEED</div><div class="value">${sSeed}</div></div>
            <div class="kv"><div class="sm">FIRST</div><div class="value">${first}</div></div>
            <div class="kv"><div class="sm">ELO</div><div class="value">${sElo}</div></div>
            <div class="kv"><div class="sm">WON</div><div class="value">${sW}</div></div>
            <div class="kv"><div class="sm">LOST</div><div class="value">${sL}</div></div>
          </div>
        </div>`;
        });

        // plrStats
        (function renderPlrStats() {
          const statsArr = plrData.plrStats || [];
          // labels correspond to each index in the provided array
          const labels = [
            'Parried', // [count, total dmg] (times I parried)
            'Blocked',
            'Dodged',
            'Damage Taken',
            'Parried By', // enemies parried my attacks
            'Blocked By',
            'Dodged By',
            'Damage Dealt',
            'Feinted Basic', // single number
            'Feinted Ability' // single number
          ];

          const fmtN = n => (typeof n === 'number' ? n.toLocaleString() : esc(String(n)));

          // helper to extract pair or number
          const getPair = i => {
            const v = statsArr[i];
            if (Array.isArray(v) && v.length >= 2) return { count: Number(v[0]) || 0, dmg: Number(v[1]) || 0 };
            if (typeof v === 'number') return { count: Number(v) || 0, dmg: 0 };
            return { count: 0, dmg: 0 };
          };

          // incoming event indices (how incoming attacks resolved for the player)
          const incomingIdx = [0, 1, 2, 3]; // parried, blocked, dodged, dmgTaken
          const incoming = incomingIdx.map(getPair);
          const totalIncoming = incoming.reduce((s, p) => s + p.dmg, 0);

          // outgoing event indices (how enemies resolved my attacks)
          const outgoingIdx = [4, 5, 6]; // parriedBy, blockedBy, dodgedBy
          const damageDealt = getPair(7); // counts + dmg for my successful hits
          const outgoing = outgoingIdx.map(getPair);
          const totalOutgoing = outgoing.reduce((s, p) => s + p.dmg, 0) + (damageDealt.dmg || 0);

          // color map shared for both incoming and outgoing corresponding types
          const sharedColors = {
            parry: 'linear-gradient(90deg,var(--accent), #d99b3a)', // gold
            block: 'linear-gradient(90deg,#60a5fa, #2b78e6)', // blue
            dodge: 'linear-gradient(90deg,#86efac, #43c46b)', // light green
            damage: 'linear-gradient(90deg,#ff8b8b, #ff4b4b)' // red
          };

          // mapping from index -> shared color key
          const idxColorKey = {
            0: 'parry',
            1: 'block',
            2: 'dodge',
            3: 'damage',
            4: 'parry', // parriedBy -> gold
            5: 'block', // blockedBy -> blue
            6: 'dodge', // dodgedBy -> light green
            7: 'damage' // damageDealt -> red (same as damageTaken)
          };

          plrStatsGrid.innerHTML = '';

          for (let i = 0; i < labels.length; i++) {
            const lab = labels[i] || `stat${i}`;
            const v = statsArr[i];
            const item = document.createElement('div');
            item.className = 'combat-item';

            // Incoming indices: show "count (X dmg)" and a big percent
            if (incomingIdx.includes(i)) {
              const p = getPair(i);
              const count = p.count;
              const dmg = p.dmg;
              const pct = totalIncoming ? (dmg / totalIncoming * 100) : 0;

              const color = sharedColors[idxColorKey[i]] || 'linear-gradient(90deg,var(--accent),#79b8ff)';

              item.innerHTML = `\n                <div class="k">${esc(lab)}</div>\n                <div style="display:flex;align-items:center;justify-content:space-between">\n                  <div class="v">${fmtN(count)} (${fmtN(dmg)} dmg)</div>\n                  <div style="font-size:12px;margin-left:8px">${pct ? pct.toFixed(1) + '%' : '—'}</div>\n                </div>\n                <div style="height:10px;width:100%;background:rgba(255,255,255,0.03);border-radius:8px;margin-top:8px;overflow:hidden">\n                  <div style="height:100%;width:${pct.toFixed(2)}%;background:${color};transition:width .4s ease"></div>\n                </div>\n              `;

            // Damage Dealt special case (outgoing success)
            } else if (i === 7) {
              const p = getPair(i);
              const count = p.count;
              const dmg = p.dmg;
              const pct = totalOutgoing ? (dmg / totalOutgoing * 100) : 0;
              const color = sharedColors[idxColorKey[i]] || 'linear-gradient(90deg,var(--accent),#79b8ff)';

              item.innerHTML = `\n                <div class="k">${esc(lab)}</div>\n                <div style="display:flex;align-items:center;justify-content:space-between;margin-top:6px">\n                  <div class="v">${fmtN(count)} (${fmtN(dmg)} dmg)</div>\n                  <div style="font-size:12px;margin-left:8px">${pct ? pct.toFixed(1) + '%' : '—'}</div>\n                </div>\n                <div style="height:10px;width:100%;background:rgba(255,255,255,0.03);border-radius:8px;margin-top:8px;overflow:hidden">\n                  <div style="height:100%;width:${pct.toFixed(2)}%;background:${color};transition:width .4s ease"></div>\n                </div>\n              `;

            // Outgoing indices: same treatment but use outgoing totals and mapped colors
            } else if (outgoingIdx.includes(i)) {
              const p = getPair(i);
              const count = p.count;
              const dmg = p.dmg;
              const pct = totalOutgoing ? (dmg / totalOutgoing * 100) : 0;
              const color = sharedColors[idxColorKey[i]] || 'linear-gradient(90deg,#9dd3ff,#60a5fa)';

              item.innerHTML = `\n                <div class="k">${esc(lab)}</div>\n                <div style="display:flex;align-items:center;justify-content:space-between;margin-top:6px">\n                  <div class="v">${fmtN(count)} (${fmtN(dmg)} dmg)</div>\n                  <div style="font-size:12px;margin-left:8px">${pct ? pct.toFixed(1) + '%' : '—'}</div>\n                </div>\n                <div style="height:10px;width:100%;background:rgba(255,255,255,0.03);border-radius:8px;margin-top:8px;overflow:hidden">\n                  <div style="height:100%;width:${pct.toFixed(2)}%;background:${color};transition:width .4s ease"></div>\n                </div>\n              `;

            // single-number feints or unknowns
            } else if (typeof v === 'number') {
              item.innerHTML = `\n                <div class="k">${esc(lab)}</div>\n                <div class="v">${fmtN(v)}</div>\n              `;

            } else {
              item.innerHTML = `\n                <div class="k">${esc(lab)}</div>\n                <div class="v">—</div>\n              `;
            }

            plrStatsGrid.appendChild(item);
          }
        })();

      } catch (err) {
        slots.innerHTML = '<div class="sm error">Failed to load</div>';
        sub.textContent = 'Network error';
        console.error(err);
      }

      // redraw on resize to keep crispness and fit
      let resizeTimeout;
      window.addEventListener('resize', () => {
        clearTimeout(resizeTimeout);
        resizeTimeout = setTimeout(() => {
          // re-render using current JSON content in the pre (if any)
          try {
            const data = JSON.parse(touch.textContent || '[]');
            renderTouch(data);
          } catch (e) {
            // ignore
          }
        }, 120);
      });
    })();
  </script>
</body>

</html>
