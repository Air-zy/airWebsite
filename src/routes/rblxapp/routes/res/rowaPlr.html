<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>DisplayName @Username</title>
<style>
  :root{--bg:#000000;--card:#0f1720;--muted:#9aa6b2;--accent:#fab760;--glass:rgba(255,255,255,0.03)}
  html,body{height:100%;margin:0;background:linear-gradient(342deg,var(--bg),#2a2a2a);color:#e6eef6;font-family:Inter,system-ui,Segoe UI,Roboto,Arial}
  .wrap{max-width:920px;margin:36px auto;padding:18px}
  .card{background:#00000030;border-radius:12px;padding:16px;box-shadow:0 6px 30px rgba(12, 6, 2, 0.6);border:1px solid rgba(255,255,255,0.02)}
  header{display:flex;align-items:center;justify-content:space-between}
  h1{font-size:20px;margin:0;color:#fff}
  h1 a{color:inherit;text-decoration:none}
  .sub{color:var(--muted);font-size:13px}
  .stats{display:flex;gap:10px;margin-top:14px;flex-wrap:wrap}
  .stat{background:var(--glass);padding:10px;border-radius:10px;min-width:110px;text-align:center}
  .label{color:var(--muted);font-size:12px}
  .value{font-weight:700;font-size:18px;color:#fff}
  .big{font-size:28px;color:var(--accent);font-weight:800}
  main{margin-top:16px;display:grid;grid-template-columns:1fr 320px;gap:14px}
  details{background:rgba(255,255,255,0.02);padding:10px;border-radius:8px;color:var(--muted)}
  summary{cursor:pointer;font-weight:700;color:#fff}
  .slots{display:flex;flex-direction:column;gap:8px}
  .slot{padding:10px;border-radius:8px;background:linear-gradient(180deg,rgba(255,255,255,0.01),rgba(255,255,255,0.005));border:1px solid rgba(255,255,255,0.02)}
  .slot h3{margin:0 0 6px 0;font-size:14px}
  .row{display:flex;gap:10px;flex-wrap:wrap}
  .kv{min-width:110px;color:var(--muted);font-size:13px}
  .sm{font-size:12px;color:var(--muted)}
  .error{color:#ffa3a3}
  #touchCanvas{width:100%;height:220px;border-radius:8px;background:linear-gradient(180deg,rgba(255,255,255,0.01),transparent);display:block}
  #touchWrap{padding:8px;border-radius:8px;background:rgba(255,255,255,0.01);margin-top:8px}
  @media(max-width:880px){main{grid-template-columns:1fr}}
</style>
</head>
<body>
<div class="wrap">
  <div class="card">
    <header>
      <div>
        <h1 id="playerId"><a id="playerLink" href="#" target="_blank" rel="noopener">—</a></h1>
        <div class="sub" id="sub">Fetching /api/rowa/{id}</div>
      </div>
    </header>

    <div class="stats" id="stats"></div>

    <main>
      <section>
        <div class="sm" style="margin-bottom:6px">Slots</div>
        <div class="slots" id="slots"><div class="sm">Loading...</div></div>
      </section>

      <aside>
        <div style="margin-bottom:12px">
          <div class="sm">Meta</div>
          <div style="padding:12px;margin-top:8px;border-radius:8px;background:rgba(255,255,255,0.02);">
            <div class="sm">First seen</div>
            <div id="metaFirst" class="value">—</div>
            <div class="sm" id="playtime">Total playtime —</div>
          </div>
        </div>

        <details>
          <summary>Keybinds <span id="kcount" class="sm"></span></summary>
          <pre id="kbPre" style="margin-top:8px;white-space:pre-wrap;color:var(--muted)"></pre>
        </details>

        <details style="margin-top:10px">
          <summary>Touch Data <span id="tcount" class="sm"></span></summary>

          <div id="touchWrap">
            <!-- canvas visualization (drawn if data exists) -->
            <canvas id="touchCanvas" aria-label="Touch visualization"></canvas>

            <!-- raw JSON fallback / debug -->
            <pre id="touchPre" style="margin-top:8px;white-space:pre-wrap;color:var(--muted)"></pre>
          </div>
        </details>
      </aside>
    </main>
  </div>
</div>

<script>
(async function(){
  const segments = location.pathname.split('/').filter(Boolean);
  const id = segments.at(-1) || 'unknown';

  const link = document.getElementById('playerLink');
  const sub = document.getElementById('sub');
  const stats = document.getElementById('stats');
  const slots = document.getElementById('slots');
  const metaF = document.getElementById('metaFirst');
  const play = document.getElementById('playtime');
  const kb = document.getElementById('kbPre');
  const touch = document.getElementById('touchPre');
  const kc = document.getElementById('kcount');
  const tc = document.getElementById('tcount');
  const canvas = document.getElementById('touchCanvas');

  const esc = s => String(s).replaceAll('&','&amp;').replaceAll('<','&lt;')
                            .replaceAll('>','&gt;').replaceAll('"','&quot;')
                            .replaceAll("'",'&#39;');

  // DisplayName + Username from <title>
  const t = document.title.trim();
  let display = id;
  const match = t.match(/^(.+?)\s*@(.+)$/);
  if (match) {
    const [_, d, n] = match;
    display = `${esc(d)} (@${esc(n)})`;
  }

  link.href = `https://www.roblox.com/users/${encodeURIComponent(id)}/profile`;
  link.textContent = display;
  sub.textContent = '/api/rowa/' + id;

  const fmtDate = s => {
    if (!s) return '—';
    const n = Number(s);
    if (isNaN(n)) return '—';
    return new Date(n*1000).toLocaleDateString('en-US',{month:'short',day:'numeric',year:'numeric'});
  };
  const fmtPlay = sec => {
    if (!sec && sec !== 0) return '—';
    const h = Math.floor(sec/3600), m = Math.floor((sec%3600)/60);
    return `${h}h ${m}m`;
  };

  // Action names for keybindData
  const keybindNames = {
    1:"sprint",2:"parry",3:"dash",4:"feint",5:"slide",
    6:"heavy",7:"light",8:"ability",
    9:"hotbar1",10:"hotbar2",11:"hotbar3",12:"hotbar4",
    13:"hotbar5",14:"hotbar6",15:"hotbar7",16:"hotbar8",
    17:"hotbar9",18:"hotbar10"
  };

  // Friendly names for special/large keycodes (optional)
  const specialKeyNames = {
    306: "LeftCntrl",
    305: "RightCntrl",
    307: "RightAlt",
    308: "LeftAlt",
    0: "M1",
    1: "M2",
    2: "M3",
    3: "M4",
    4: "M5",
    5: "M6",
    13: "Enter",
    27: "Escape",
    32: "Space",
    37: "ArrowLeft",
    38: "ArrowUp",
    39: "ArrowRight",
    40: "ArrowDown",
  };

  function prettyKey(code) {
    if (code === -1) return "None";
    if (code == null) return "None";
    if (specialKeyNames[code]) return `${specialKeyNames[code]}`;
    if (code >= 32 && code <= 126) {
      const ch = String.fromCharCode(code);
      if (/[a-zA-Z0-9]/.test(ch)) return `${ch.toUpperCase()}`;
      return `${ch} (${code})`;
    }
    return `Key(${code})`;
  }

  function clearCanvas() {
    const ctx = canvas.getContext('2d');
    ctx.save();
    ctx.setTransform(1,0,0,1,0,0);
    ctx.clearRect(0,0,canvas.width,canvas.height);
    ctx.restore();
  }

  function renderTouch(tdata) {
    // tdata expected: [[x,y,size], ...]
    const ctx = canvas.getContext('2d');
    // resize canvas for crispness (use client size + DPR)
    const DPR = window.devicePixelRatio || 1;
    const cw = Math.max(200, canvas.clientWidth || 300);
    const ch = Math.max(120, canvas.clientHeight || 220);
    canvas.style.height = ch + 'px';
    canvas.width = Math.round(cw * DPR);
    canvas.height = Math.round(ch * DPR);
    ctx.scale(DPR, DPR);
    ctx.clearRect(0,0,cw,ch);

    if (!Array.isArray(tdata) || tdata.length === 0) {
      // draw "no data" message
      ctx.font = '13px system-ui, Inter, Arial';
      ctx.fillStyle = 'rgba(255,255,255,0.06)';
      ctx.fillRect(0,0,cw,ch);
      ctx.fillStyle = 'var(--muted)';
      ctx.textAlign = 'center';
      ctx.fillText('No touch data to visualize', cw/2, ch/2);
      return;
    }

    // filter valid points: ensure numbers
    const pts = tdata.map(p => [Number(p[0]), Number(p[1]), Number(p[2])]).filter(p => !Number.isNaN(p[0]) && !Number.isNaN(p[1]));
    if (pts.length === 0) {
      ctx.fillStyle = 'var(--muted)';
      ctx.textAlign = 'center';
      ctx.fillText('No valid touch points', cw/2, ch/2);
      return;
    }

    // compute bounds
    let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
    pts.forEach(p => {
      if (p[0] < minX) minX = p[0];
      if (p[0] > maxX) maxX = p[0];
      if (p[1] < minY) minY = p[1];
      if (p[1] > maxY) maxY = p[1];
    });

    // if degenerate, expand a little to avoid zero scale
    if (minX === maxX) { minX -= 1; maxX += 1; }
    if (minY === maxY) { minY -= 1; maxY += 1; }

    // padding (pixels)
    const pad = Math.min(40, Math.min(cw, ch) * 0.12);

    const usableW = cw - pad * 2;
    const usableH = ch - pad * 2;

    const dataW = maxX - minX;
    const dataH = maxY - minY;

    const scaleX = usableW / dataW;
    const scaleY = usableH / dataH;
    // keep aspect: choose the smaller scale so everything fits
    const scale = Math.min(scaleX, scaleY);

    // center the data in the usable area
    const drawnW = dataW * scale;
    const drawnH = dataH * scale;
    const offsetX = pad + ((usableW - drawnW) / 2) - minX * scale;
    const offsetY = pad + ((usableH - drawnH) / 2) - minY * scale;

    // background
    ctx.fillStyle = 'rgba(255,255,255,0.01)';
    ctx.fillRect(0,0,cw,ch);

    // draw bounding box (input bounds)
    ctx.save();
    ctx.strokeStyle = 'rgba(255,255,255,0.12)';
    ctx.setLineDash([5,4]);
    ctx.lineWidth = 1;
    ctx.strokeRect(offsetX, offsetY, drawnW, drawnH);
    ctx.restore();

    // draw points
    pts.forEach((p, i) => {
      const x = offsetX + p[0] * scale;
      const y = offsetY + p[1] * scale;
      const radius = Math.max(2, (p[2] || 8) * 0.5 * scale); // size interpreted as diameter-ish; scale it
      // filled translucent circle
      ctx.beginPath();
      ctx.fillStyle = 'rgba(96,165,250,0.12)'; // semi-transparent accent
      ctx.arc(x, y, radius, 0, Math.PI*2);
      ctx.fill();
      // outline
      ctx.lineWidth = 1.2;
      ctx.strokeStyle = 'rgba(96,165,250,0.9)';
      ctx.stroke();

      // index label (small)
      ctx.font = '10px system-ui, Inter, Arial';
      ctx.fillStyle = 'rgba(255,255,255,0.9)';
      ctx.textAlign = 'center';
      ctx.fillText(String(i+1), x, y - radius - 6);
    });

    // draw min/max label text
    ctx.font = '11px system-ui, Inter, Arial';
    ctx.fillStyle = 'rgba(255,255,255,0.85)';
    ctx.textAlign = 'left';
    ctx.fillText(`x: ${minX} → ${maxX}`, 8, ch - 28);
    ctx.fillText(`y: ${minY} → ${maxY}`, 8, ch - 12);
  }

  try {
    const res = await fetch('/api/rowa/' + encodeURIComponent(id));
    if (!res.ok) {
      slots.innerHTML = '<div class="sm error">Failed to load</div>';
      sub.textContent = 'Error: ' + res.status;
      return;
    }
    const j = await res.json();

    // Stats
    const wins = +j.wins || 0, loss = +j.loss || 0, total = wins + loss;
    const winrate = total ? (wins/total*100).toFixed(2)+'%' : '—';
    const elo = j.elo ?? '—', seed = j.seed ?? '—';
    const stat = (l,v,b) => `<div class="stat"><div class="label">${l}</div><div class="${b?'big':'value'}">${v}</div></div>`;
    stats.innerHTML = stat('Wins', wins) + stat('Losses', loss) + stat('Winrate', winrate) + stat('ELO', esc(elo)) + stat('Seed', esc(seed));

    // Meta
    metaF.textContent = fmtDate(j.meta?.first);
    play.textContent = 'Total playtime — ' + fmtPlay(j.meta?.totalPlaytime || j.meta?.total || 0);

    // Keybinds — now pretty-printed with key names
    const k = j.keybindData || [];
    kc.textContent = '(' + k.length + ')';
    let out = "";
    for (let i = 0; i < k.length; i++) {
      const name = keybindNames[i+1] || `action${i+1}`;
      const pair = k[i] || [];
      const b1 = (pair.length>0) ? pair[0] : -1;
      const b2 = (pair.length>1) ? pair[1] : -1;
      out += `${name}: ${prettyKey(b1)}, ${prettyKey(b2)}\n`;
    }
    kb.textContent = out;

    // Touch Data
    const td = j.touchData || [];
    touch.textContent = JSON.stringify(td, null, 2);
    tc.textContent = '(' + td.length + ')';
    // render visualization (if present)
    try {
      renderTouch(td);
    } catch (err) {
      console.error('renderTouch failed', err);
      // fallback: clear canvas and print error
      clearCanvas();
      const ctx = canvas.getContext('2d');
      ctx.font = '13px system-ui, Inter, Arial';
      ctx.fillStyle = 'var(--muted)';
      ctx.textAlign = 'center';
      ctx.fillText('Visualization error', canvas.clientWidth/2, canvas.clientHeight/2);
    }

    // Slots
    slots.innerHTML = '';
    (j.slots||[]).forEach((s,i)=>{
      const name = esc(s[0] || `Slot ${i+1}`);
      const sSeed = esc(s[1] ?? '—');
      const first = fmtDate(s[3]?.first);
      const sElo = esc(s[5] ?? '—'), sW = s[6] ?? 0, sL = s[7] ?? 0;
      slots.innerHTML += `
        <div class="slot">
          <h3>${name}</h3>
          <div class="row">
            <div class="kv"><div class="sm">Seed</div><div class="value">${sSeed}</div></div>
            <div class="kv"><div class="sm">First</div><div class="value">${first}</div></div>
            <div class="kv"><div class="sm">Slot ELO</div><div class="value">${sElo}</div></div>
            <div class="kv"><div class="sm">Wins</div><div class="value">${sW}</div></div>
            <div class="kv"><div class="sm">Losses</div><div class="value">${sL}</div></div>
          </div>
        </div>`;
    });

  } catch (err) {
    slots.innerHTML = '<div class="sm error">Failed to load</div>';
    sub.textContent = 'Network error';
    console.error(err);
  }

  // redraw on resize to keep crispness and fit
  let resizeTimeout;
  window.addEventListener('resize', () => {
    clearTimeout(resizeTimeout);
    resizeTimeout = setTimeout(() => {
      // re-render using current JSON content in the pre (if any)
      try {
        const data = JSON.parse(touch.textContent || '[]');
        renderTouch(data);
      } catch (e) {
        // ignore
      }
    }, 120);
  });
})();
</script>
</body>
</html>
