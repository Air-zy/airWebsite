// minified by avy <3
import{transTable,myHuge,myHuge2,getZobrist,gameState,genValidDrops,rawDrop,rawUndrop,tokenGridHeights,checkWin,checkWin2,cols,rows,weightingGridInvert,tokenGrid,weightingGrid}from"./c4main.js";function delay(e){return new Promise((t=>setTimeout(t,e)))}function additive(e,t){return e>0?e+t:e<0?e-t:e}function heuristic(){let e=0,t=0,i=0;for(let n=0;n<cols;n++){const r=tokenGridHeights[n];if(r+1<=rows){const t=checkWin2(n,r+1,1),i=checkWin2(n,r+1,2);t?e-=400:i&&(e+=400)}const o=checkWin(n,r);if(2==o?++i:1==o&&++t,i>=2)return-myHuge2;if(t>=2)return myHuge2;let a=0;for(let t=0;t<r;t++){const i=tokenGrid[n][t];a==i&&n>0&&n<cols-1&&(tokenGridHeights[n-1]<r||tokenGridHeights[n+1]>r)&&(2==i?e+=weightingGridInvert[n][t]:1==i&&(e-=weightingGridInvert[n][t])),a=i,2==i?e-=weightingGrid[n][t]:1==i&&(e+=weightingGrid[n][t])}}return e}let cint=0,nodes=0;function resetNodes(){nodes=0}async function minmax(e,t,i,n,r){++nodes;const o=getZobrist(),a=transTable.get(o,t);if(a)return a;if(1==gameState)return[myHuge-e];if(2==gameState)return[-myHuge+e];if(0==t)return++cint,cint>4e3&&(cint=0,await delay(1)),[additive(heuristic(),e)];const s=genValidDrops();if(0==s.length)return[0];let g=s[0];if(i){let i=-myHuge;for(let o=0;o<s.length;++o){rawDrop(s[o]);let[a,c]=await minmax(e+1,t-1,!1,n,r);if(rawUndrop(),a>i&&(g=s[o],i=a),a>=r)break;a>n&&(n=a)}return transTable.set(o,i,g,t),[i,g]}{let i=myHuge;for(let o=0;o<s.length;++o){rawDrop(s[o]);let[a,c]=await minmax(e+1,t-1,!0,n,r);if(rawUndrop(),a<i&&(g=s[o],i=a),a<=n)break;a<r&&(r=a)}return transTable.set(o,i,g,t),[i,g]}}export{minmax,nodes,resetNodes};