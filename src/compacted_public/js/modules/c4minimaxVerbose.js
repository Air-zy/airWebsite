// minified by avy <3
import{transTable,myHuge,myHuge2,getZobrist,gameState,genValidDrops,rawDrop,rawUndrop,tokenGridHeights,checkWin,checkWin2,cols,rows,weightingGridInvert,tokenGrid,weightingGrid}from"./c4main.js";function delay(e){return new Promise((t=>setTimeout(t,e)))}function additive(e,t){return e>0?e+t:e<0?e-t:e}function heuristic(){let e=0,t=0,n=0;for(let i=0;i<cols;i++){const r=tokenGridHeights[i];if(r+1<=rows){const t=checkWin2(i,r+1,1),n=checkWin2(i,r+1,2);t?e-=400:n&&(e+=400)}const s=checkWin(i,r);if(2==s?++n:1==s&&++t,n>=2)return-myHuge2;if(t>=2)return myHuge2;let o=0;for(let t=0;t<r;t++){const n=tokenGrid[i][t];o==n&&i>0&&i<cols-1&&(tokenGridHeights[i-1]<r||tokenGridHeights[i+1]>r)&&(2==n?e+=weightingGridInvert[i][t]:1==n&&(e-=weightingGridInvert[i][t])),o=n,2==n?e-=weightingGrid[i][t]:1==n&&(e+=weightingGrid[i][t])}}return e}let cint=0,nodes=0,wins=0,leafs=0;function resetNodes(){nodes=0,wins=0,leafs=0}async function minmax(e,t,n,i,r){++nodes;const s=getZobrist(),o=transTable.get(s,t);if(o)return o;if(1==gameState)return++wins,[myHuge-e];if(2==gameState)return--wins,[-myHuge+e];if(0==t)return++leafs,++cint,cint>4e3&&(cint=0,await delay(1)),[additive(heuristic(),e)];const a=genValidDrops();if(0==a.length)return[0];let g=[];if(n){let n=-myHuge,o=0;for(let s=0;s<a.length;++s){rawDrop(a[s]);let[l,c,u]=await minmax(e+1,t-1,!1,i,r);if(rawUndrop(),l>n&&(o=a[s],n=l,null!=u&&(g=u)),l>=r)break;l>i&&(i=l)}return transTable.set(s,n,o,t),g&&g.push([o,wins,leafs]),[n,o,g]}{let n=0,o=myHuge;for(let s=0;s<a.length;++s){rawDrop(a[s]);let[l,c,u]=await minmax(e+1,t-1,!0,i,r);if(rawUndrop(),l<o&&(n=a[s],o=l,null!=u&&(g=u)),l<=i)break;l<r&&(r=l)}return transTable.set(s,o,n,t),g&&g.push([n,wins,nodes]),[o,n,g]}}export{minmax,nodes,resetNodes};