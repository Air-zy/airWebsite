// minified by avy <3
class IntStack{constructor(){this.stack=[],this.top=-1}push(t){this.stack[++this.top]=t}pop(){if(this.top>=0){const t=this.stack[this.top];return this.stack[this.top--]=void 0,t}}reset(){this.stack=[],this.top=-1}}class TranspositionTable{constructor(){this.map=new Map}set(t,e,n,r){this.map.set(t,{score:e,bestMove:n,depth:r})}get(t,e){const n=this.map.get(t);if(n){if(n.depth<=e)return;return[n.score,n.bestMove]}}clear(){this.map.clear()}}function getRandomUint32(){return Math.floor(Math.random()*2**32)>>>0}function delay(t){return new Promise((e=>setTimeout(e,t)))}const transTable=new TranspositionTable,moveStack=new IntStack;let weightingGrid,weightingGridInvert,cols=7,rows=6,connectIn=4,redIsAI=!1,yelIsAI=!0,turn=1,gameState=0,tokenGrid=[[0,0,0,0,0,0],[0,0,0,0,0,0],[0,0,0,0,0,0],[0,0,0,0,0,0],[0,0,0,0,0,0],[0,0,0,0,0,0],[0,0,0,0,0,0]];makeWeightingGrid();let zobristGridRed=new Array(cols),zobristGridYellow=new Array(cols);for(let t=0;t<cols;t++){zobristGridRed[t]=new Uint32Array(rows),zobristGridYellow[t]=new Uint32Array(rows);for(let e=0;e<rows;e++)zobristGridRed[t][e]=getRandomUint32(),zobristGridYellow[t][e]=getRandomUint32()}console.log(weightingGrid,zobristGridRed,zobristGridYellow);let tokenGridHeights=[0,0,0,0,0,0,0],midMoveOrderPreset=[3,2,4,1,5,0,6];function makeWeightingGrid(){if(!(parseInt(cols)&&parseInt(cols)>0&&parseInt(rows)&&parseInt(rows)>0))return;const t=new Array(cols);for(let e=0;e<cols;e++)t[e]=new Array(rows);for(let e=0;e<cols;e++)for(let n=0;n<rows;n++)t[e][n]=0;const e=rows-1,n=cols-1;weightingGrid=t.map(((t,r)=>t.map(((t,o)=>{let s=Math.abs(n-2*r),i=Math.abs(e+1-2*o);return 0==o&&(i+=2),parseInt((2*s+2*i)**.7)}))));const r=parseInt((2*rows+2*cols)**.5);weightingGridInvert=t.map(((t,o)=>t.map(((t,s)=>{let i=Math.abs(n-2*o),c=Math.abs(2*e-2*s);return Math.max(2*(r-parseInt((2*i+2*c)**.5)),1)}))))}function resetGame(){if(!(parseInt(cols)&&parseInt(cols)>0&&parseInt(rows)&&parseInt(rows)>0))return;gameState=0,transTable.clear(),moveStack.reset(),turn=1;const t=new Array(cols);for(let e=0;e<cols;e++)t[e]=new Array(rows);tokenGridHeights=new Uint8Array(cols);for(let e=0;e<cols;e++){tokenGridHeights[e]=0;for(let n=0;n<rows;n++)t[e][n]=0}const e=rows-1,n=cols-1;weightingGrid=t.map(((t,r)=>t.map(((t,o)=>{let s=Math.abs(n-2*r),i=Math.abs(e+1-2*o);return 0==o&&(i+=2),parseInt((2*s+2*i)**.7)}))));const r=parseInt((2*rows+2*cols)**.5);weightingGridInvert=t.map(((t,o)=>t.map(((t,s)=>{let i=Math.abs(n-2*o),c=Math.abs(2*e-2*s);return Math.max(2*(r-parseInt((2*i+2*c)**.5)),1)})))),zobristGridRed=new Array(cols),zobristGridYellow=new Array(cols);for(let t=0;t<cols;t++){zobristGridRed[t]=new Uint32Array(rows),zobristGridYellow[t]=new Uint32Array(rows);for(let e=0;e<rows;e++)zobristGridRed[t][e]=getRandomUint32(),zobristGridYellow[t][e]=getRandomUint32()}tokenGrid=t;Array.from({length:cols},((t,e)=>e));const o=Array.from({length:cols},((t,e)=>e)),s=Math.floor(o.length/2);o.sort(((t,e)=>{const n=Math.abs(t-s),r=Math.abs(e-s);return n!==r?n-r:t-e})),midMoveOrderPreset=o,console.log(weightingGrid)}function setCol(t){cols=t}function setRow(t){rows=t}function setConnectIn(t){connectIn=t}function setRedIsAI(t){redIsAI=t}function setYelIsAI(t){yelIsAI=t}function flipTurns(){turn=1==turn?2:1}function checkWin(t,e){const n=3-turn;let r=1;for(let o=1;o<connectIn&&(tokenGrid[t+o]&&tokenGrid[t+o][e]==n);++o)if(++r,r==connectIn)return turn;for(let o=1;o<connectIn&&(tokenGrid[t-o]&&tokenGrid[t-o][e]==n);++o)if(++r,r==connectIn)return turn;if(tokenGridHeights[t]>=connectIn){let r=1;for(let o=1;o<connectIn&&tokenGrid[t][e-o]==n;++o)if(++r,r==connectIn)return turn}let o=1;for(let r=1;r<connectIn;++r){const s=tokenGrid[t+r];if(!s||!s[e+r]||s[e+r]!=n)break;if(++o,o==connectIn)return turn}for(let r=1;r<connectIn;++r){const s=tokenGrid[t-r];if(!s||!s[e-r]||s[e-r]!=n)break;if(++o,o==connectIn)return turn}let s=1;for(let r=1;r<connectIn;++r){const o=tokenGrid[t+r];if(!o||!o[e-r]||o[e-r]!=n)break;if(++s,s==connectIn)return turn}for(let r=1;r<connectIn;++r){const o=tokenGrid[t-r];if(!o||!o[e+r]||o[e+r]!=n)break;if(++s,s==connectIn)return turn}return 0}function checkWin2(t,e,n){let r=1;for(let o=1;o<connectIn&&(tokenGrid[t+o]&&tokenGrid[t+o][e]==n);++o)if(++r,r==connectIn)return turn;for(let o=1;o<connectIn&&(tokenGrid[t-o]&&tokenGrid[t-o][e]==n);++o)if(++r,r==connectIn)return turn;if(tokenGridHeights[t]>=connectIn){let r=1;for(let o=1;o<connectIn&&tokenGrid[t][e-o]==n;++o)if(++r,r==connectIn)return turn}let o=1;for(let r=1;r<connectIn;++r){const s=tokenGrid[t+r];if(!s||!s[e+r]||s[e+r]!=n)break;if(++o,o==connectIn)return turn}for(let r=1;r<connectIn;++r){const s=tokenGrid[t-r];if(!s||!s[e-r]||s[e-r]!=n)break;if(++o,o==connectIn)return turn}let s=1;for(let r=1;r<connectIn;++r){const o=tokenGrid[t+r];if(!o||!o[e-r]||o[e-r]!=n)break;if(++s,s==connectIn)return turn}for(let r=1;r<connectIn;++r){const o=tokenGrid[t-r];if(!o||!o[e+r]||o[e+r]!=n)break;if(++s,s==connectIn)return turn}return 0}function rawDrop(t){if(0!=gameState)return;const e=tokenGridHeights[t];e<rows&&(moveStack.push(t),tokenGrid[t][e]=turn,++tokenGridHeights[t],flipTurns(),gameState=checkWin(t,e))}function rawUndrop(){gameState=0;const t=moveStack.pop();(t||0==t)&&(--tokenGridHeights[t],tokenGrid[t][tokenGridHeights[t]]=0,flipTurns())}function genValidDrops(){let t=[];for(let e=0;e<cols;e++)tokenGridHeights[midMoveOrderPreset[e]]<rows&&t.push(midMoveOrderPreset[e]);return t}function getZobrist(){let t=0;for(let e=0;e<cols;e++)for(let n=0;n<tokenGridHeights[e];n++){const r=tokenGrid[e][n];t=1==r?t^r^zobristGridRed[e][n]:t^r^zobristGridYellow[e][n]}return t}const myHuge=1e5,myHuge2=1e4;import{minmax,nodes,resetNodes}from"./c4minimaxVerbose.js";export{transTable,moveStack,cols,rows,connectIn,redIsAI,yelIsAI,setRedIsAI,setYelIsAI,turn,gameState,tokenGrid,tokenGridHeights,setCol,setRow,setConnectIn,resetGame,rawDrop,rawUndrop,genValidDrops,minmax,myHuge,myHuge2,nodes,resetNodes,IntStack,getZobrist,checkWin,checkWin2,weightingGrid,weightingGridInvert};