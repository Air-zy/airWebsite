<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Fights (Glicko-2)</title>
  <style>
    :root { font-family: Inter, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial; }
    body { margin: 20px; background:#0f172a; color:#e6eef8; }
    h1 { margin:0 0 10px 0; font-size:20px; }
    .container { display:grid; grid-template-columns: 380px 1fr; gap:18px; align-items:start; }
    .panel { background: linear-gradient(180deg, rgba(255,255,255,0.03), rgba(255,255,255,0.02)); border-radius:10px; padding:12px; box-shadow: 0 6px 18px rgba(2,6,23,0.6); }
    .controls { display:flex; flex-direction:column; gap:10px; }
    label { font-size:12px; color:#9fb0d6; }
    .slider-row { display:flex; gap:8px; align-items:center; }
    input[type="range"] { width:100%; }
    .stats { font-size:13px; color:#cfe0ff; display:flex; gap:12px; flex-wrap:wrap; }
    .leaderboard { margin-top:8px; max-height:420px; overflow:auto; border-radius:8px; padding:8px; background: rgba(255,255,255,0.01); }
    .leader-item { display:flex; justify-content:space-between; gap:8px; padding:6px 8px; border-radius:6px; margin-bottom:6px; background: linear-gradient(90deg, rgba(255,255,255,0.01), transparent); font-family:monospace; }
    .leader-item strong { color:#ffd66b; }
    pre#output { max-height:460px; overflow:auto; background:transparent; color:#bfe0ff; font-size:12px; padding:8px; margin:0; border-radius:6px; }
    .hint { font-size:12px; color:#9fb0d6; margin-top:8px; }
    .footer { margin-top:12px; color:#93b4dd; font-size:13px; }
    .box-title { font-size:13px; color:#cbe3ff; margin-bottom:6px; }
  </style>
</head>
<body>
  <h1>Recent Fights — Glicko-2 Leaderboard</h1>

  <div class="container">
    <div class="panel">
      <div class="controls">
        <div class="box-title">Scroll / Slider selector</div>
        <div class="slider-row">
          <input id="percentSlider" type="range" min="0" max="100" value="100" step="1" />
          <div style="min-width:54px; text-align:right;" id="percentLabel">100%</div>
        </div>

        <div class="stats">
          <div>Max fight id: <span id="maxId">—</span></div>
          <div>Target ID (percent × max): <span id="targetId">—</span></div>
          <div>Selected fights: <span id="selectedCount">—</span></div>
        </div>

        <div class="hint">Tip: hover this panel and use the mouse wheel or touchpad to change percent quickly.</div>

        <div style="margin-top:12px;">
          <div class="box-title">Leaderboard (plrid: rating)</div>
          <div class="leaderboard" id="leaderboard">Loading…</div>
        </div>

        <div class="footer">Ratings use <strong>Glicko-2</strong> recalculated from fights ≤ targetId. Each killer vs victim pair is updated.</div>
      </div>
    </div>

    <div class="panel">
      <div class="box-title">Raw JSON (debug)</div>
      <pre id="output">Loading fights...</pre>
    </div>
  </div>

  <script>
  // ---------- Glicko-2 helpers ----------
  const TAU = 0.5;   // system constant (volatility scaling)
  const MU = 1500;
  const PHI = 350;
  const SIGMA = 0.06;

  function glicko2Init() {
    return { 
      rating: MU,      // μ
      rd: PHI,         // rating deviation
      sigma: SIGMA,    // volatility
      wins: 0,
      losses: 0
    };
  }

  function glicko2ScaleDown(r) {
    return (r - MU) / 173.7178;
  }
  function glicko2ScaleUp(r) {
    return r * 173.7178 + MU;
  }

  function g(phi) {
    return 1 / Math.sqrt(1 + (3*phi*phi) / (Math.PI*Math.PI));
  }

  function E(mu, mu_j, phi_j) {
    return 1 / (1 + Math.exp(-g(phi_j)*(mu - mu_j)));
  }

  // Update rating after a single game
  function updateGlicko2(player, opponent, score) {
    const mu = glicko2ScaleDown(player.rating);
    const phi = player.rd / 173.7178;
    const mu_j = glicko2ScaleDown(opponent.rating);
    const phi_j = opponent.rd / 173.7178;

    const E_j = E(mu, mu_j, phi_j);
    const g_phi = g(phi_j);

    const v = 1 / (g_phi*g_phi * E_j * (1 - E_j));
    const delta = v * g_phi * (score - E_j);

    // volatility update (simplified version)
    let sigmaPrime = player.sigma;

    const phiStar = Math.sqrt(phi*phi + sigmaPrime*sigmaPrime);
    const phiPrime = 1 / Math.sqrt(1/phiStar/phiStar + 1/v);
    const muPrime = mu + phiPrime*phiPrime * g_phi * (score - E_j);

    player.rating = glicko2ScaleUp(muPrime);
    player.rd = phiPrime * 173.7178;
    player.sigma = sigmaPrime;
  }

  // ---------- Simulations ----------
  function simulateGlicko2OnSelected(fightsObj, userIdMap, selectedFightIds) {
    for (const fightId of selectedFightIds) {
      const fight = fightsObj[fightId];
      if (!fight) continue;
      const victimId = fight.victim_id;
      for (const killer of fight.killers) {
        const killerId = killer.killer_id;

        updateGlicko2(userIdMap[killerId], userIdMap[victimId], 1);
        updateGlicko2(userIdMap[victimId], userIdMap[killerId], 0);

        userIdMap[killerId].wins++;
        userIdMap[victimId].losses++;
      }
    }
  }

  // ---------- Formatting helpers ----------
  function formatContributions(contributions) {
    const fights = new Map();
    for (const entry of contributions) {
      const fightId = Number(entry.fight_id);
      if (!fights.has(fightId)) {
        fights.set(fightId, { victim_id: Number(entry.victim_id), killers: [] });
      }
      fights.get(fightId).killers.push({
        killer_id: Number(entry.killer_id),
        enemy_focus_percent: Number(entry.enemy_focus_percent || 100),
        my_focus_percent: Number(entry.my_focus_percent || 100)
      });
    }
    return fights;
  }

  function buildUserIdMapFromFights(fightsObj, selectedFightIds) {
    const userIdMap = {};
    for (const fightId of selectedFightIds) {
      const fight = fightsObj[fightId];
      if (!fight) continue;
      const victimId = fight.victim_id;
      if (!userIdMap[victimId]) userIdMap[victimId] = glicko2Init();
      for (const killer of fight.killers) {
        const killerId = killer.killer_id;
        if (!userIdMap[killerId]) userIdMap[killerId] = glicko2Init();
      }
    }
    return userIdMap;
  }

  // ---------- UI ----------
  const percentSlider = document.getElementById('percentSlider');
  const percentLabel = document.getElementById('percentLabel');
  const maxIdEl = document.getElementById('maxId');
  const targetIdEl = document.getElementById('targetId');
  const selectedCountEl = document.getElementById('selectedCount');
  const leaderboardEl = document.getElementById('leaderboard');
  const outputEl = document.getElementById('output');

  let fightsMap = new Map();
  let fightsObj = {};
  let sortedFightIds = [];
  let maxFightId = 0;
  let rafId = null;

  function scheduleRender() {
    if (rafId) cancelAnimationFrame(rafId);
    rafId = requestAnimationFrame(() => {
      rafId = null;
      renderForPercent(Number(percentSlider.value) / 100);
    });
  }

  function renderForPercent(percent) {
    const targetId = Math.round(percent * maxFightId);
    const selectedFightIds = sortedFightIds.filter(id => id <= targetId);

    const userIdMap = buildUserIdMapFromFights(fightsObj, selectedFightIds);
    simulateGlicko2OnSelected(fightsObj, userIdMap, selectedFightIds);

    const leaderboardArr = Object.entries(userIdMap)
      .map(([pid, data]) => ({ pid, rating: Math.round(data.rating), wins:data.wins, losses:data.losses }))
      .sort((a,b) => b.rating - a.rating);

    percentLabel.textContent = Math.round(percent*100)+'%';
    maxIdEl.textContent = String(maxFightId || '—');
    targetIdEl.textContent = String(targetId);
    selectedCountEl.textContent = String(selectedFightIds.length);

    leaderboardEl.innerHTML = leaderboardArr.length === 0
      ? '<div style="color:#8fa9d8">No players in selection</div>'
      : leaderboardArr.slice(0,300).map(p => `
          <div class="leader-item">
            <div>#${p.pid}</div>
            <strong>${p.rating}</strong>
            <div>W:${p.wins} L:${p.losses}</div>
          </div>`).join('');

    const debug = {
      percent: Math.round(percent*100)+'%',
      targetId,
      selectedFightCount: selectedFightIds.length,
      topLeaderboard: leaderboardArr.slice(0,20)
    };
    outputEl.textContent = JSON.stringify(debug, null, 2);
  }

  const leftPanel = document.querySelectorAll('.panel')[0];
  leftPanel.addEventListener('wheel', (ev) => {
    ev.preventDefault();
    const step = ev.deltaMode === 0 ? Math.sign(-ev.deltaY)*2 : Math.sign(-ev.deltaY)*5;
    let val = Number(percentSlider.value)+step;
    val = Math.max(0, Math.min(100, val));
    percentSlider.value = val;
    scheduleRender();
  }, { passive: false });

  percentSlider.addEventListener('input', scheduleRender);
  percentSlider.addEventListener('change', scheduleRender);

  async function getFights() {
    try {
      const res = await fetch('/api/rowa/fights/recent?limit=1000');
      if (!res.ok) throw new Error(`HTTP error! Status: ${res.status}`);
      const contribData = await res.json();

      fightsMap = formatContributions(contribData.contributions || []);
      fightsObj = Object.fromEntries(fightsMap);
      sortedFightIds = Array.from(fightsMap.keys()).sort((a,b)=>a-b);
      maxFightId = sortedFightIds.length ? Math.max(...sortedFightIds) : 0;

      scheduleRender();
    } catch (err) {
      console.error('Fetch failed:', err);
      outputEl.textContent = 'Fetch failed: '+String(err);
    }
  }

  getFights();
  </script>
</body>
</html>
