<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Presence — Hour & Weekday</title>
<style>
  :root{
    --bg:#0f1113; --card:#16181a; --muted:#9aa0a6;
    --online:#2ecc71; --dnd:#e74c3c; --idle:#f1c40f; --offline:#95a5a6;
  }
  html,body{height:100%;margin:0;background:var(--bg);color:#e6eef3;font-family:Inter,system-ui,Segoe UI,Roboto,Arial}
  .wrap{max-width:960px;margin:20px auto;padding:14px;background:linear-gradient(180deg,rgba(255,255,255,0.02),transparent);border-radius:10px}
  .top{display:flex;gap:12px;align-items:center;margin-bottom:10px;font-size:13px;color:var(--muted)}
  .dot{width:10px;height:10px;border-radius:50%;display:inline-block;margin-right:6px;vertical-align:-1px}
  .charts {display:flex;flex-direction:column;gap:12px}
  /* give the canvases only a CSS height (px) — backing buffer set in JS */
  canvas { width:100%; border-radius:8px; display:block; }
</style>
</head>
<body>
  <div class="wrap">
    <div class="top">
      <span><span id="dot" class="dot" style="background:var(--offline)"></span><strong id="status">—</strong></span>
      <span id="last" style="color:var(--muted)">Last: —</span>
      <span id="count" style="color:var(--muted)">Items: —</span>
    </div>

    <div class="charts">
      <!-- no width/height attributes here -->
      <canvas id="chartHour"></canvas>
      <canvas id="chartWeek"></canvas>
    </div>
  </div>

<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<script>
/*
 Fix approach:
 - Set CSS height on each canvas (px).
 - Sync canvas.width/height to clientWidth/clientHeight * devicePixelRatio
 - Create Chart.js charts with responsive:false, maintainAspectRatio:false
 - On resize: debounce, destroy & recreate charts (so backing store syncs again)
*/

(async ()=>{

  const COLORS = {
    online:getComputedStyle(document.documentElement).getPropertyValue('--online').trim()||'#2ecc71',
    dnd:getComputedStyle(document.documentElement).getPropertyValue('--dnd').trim()||'#e74c3c',
    idle:getComputedStyle(document.documentElement).getPropertyValue('--idle').trim()||'#f1c40f',
    offline:getComputedStyle(document.documentElement).getPropertyValue('--offline').trim()||'#95a5a6'
  };
  const STATUSES = ['online','idle','dnd','offline'];

  // prepare buckets
  const hours = Array.from({length:24},(_,h)=>{
    const hour12 = ((h+11)%12)+1;
    const ampm = h<12 ? 'AM':'PM';
    return { label:`${hour12} ${ampm}`, counts:{ online:0,idle:0,dnd:0,offline:0 } };
  });
  const weekdays = ['Mon','Tue','Wed','Thu','Fri','Sat','Sun'];
  const days = weekdays.map(d=>({ label:d, counts:{ online:0,idle:0,dnd:0,offline:0 } }));

  // DOM refs
  const canvasHour = document.getElementById('chartHour');
  const canvasWeek = document.getElementById('chartWeek');
  const statusEl = document.getElementById('status');
  const dot = document.getElementById('dot');
  const lastEl = document.getElementById('last');
  const countEl = document.getElementById('count');

  // tune these CSS heights (px) to your taste
  const HOUR_CANVAS_PX = 420;
  const WEEK_CANVAS_PX = 320;

  // fetch presence and fill buckets
  let hist = [];
  try {
    const res = await fetch('/api/presence',{cache:'no-store'});
    if(!res.ok) throw new Error(res.status+' '+res.statusText);
    const payload = await res.json();
    statusEl.textContent = payload.status || '—';
    dot.style.background = COLORS[payload.status] || COLORS.offline;
    lastEl.textContent = payload.lastOn ? ('Last: '+ new Date(payload.lastOn).toLocaleString()) : 'Last: —';
    hist = Array.isArray(payload.history)? payload.history : [];
    countEl.textContent = 'Items: ' + hist.length;

    hist.forEach(item=>{
      const ts = item.timestamp || item.time;
      if(!ts) return;
      const d = new Date(ts);
      if(isNaN(d)) return;
      const h = d.getHours();
      const s = (item.status||'offline').toLowerCase();
      const st = STATUSES.includes(s) ? s : 'offline';
      hours[h].counts[st] = (hours[h].counts[st]||0)+1;
      const jsDay = d.getDay();
      const monIndex = (jsDay + 6) % 7;
      days[monIndex].counts[st] = (days[monIndex].counts[st]||0)+1;
    });

  } catch(err) {
    console.error('fetch error', err);
    statusEl.textContent = 'error';
    lastEl.textContent = err.message;
  }

  // helper: set CSS height and sync backing store
  function syncCanvasBacking(canvas, cssHeightPx) {
    canvas.style.height = cssHeightPx + 'px';
    // width via CSS is 100%
    // compute backing store size
    const dpr = window.devicePixelRatio || 1;
    // clientWidth may be fractional — use Math.floor to avoid partial pixel artifacts
    const w = Math.floor(canvas.clientWidth * dpr);
    const h = Math.floor(canvas.clientHeight * dpr);
    if (w > 0 && h > 0) {
      canvas.width = w;
      canvas.height = h;
    }
  }

  // build datasets
  function buildDatasets(buckets) {
    return STATUSES.map(s=>({
      label: s,
      data: buckets.map(b => b.counts[s] || 0),
      backgroundColor: COLORS[s],
      stack: 'a'
    }));
  }

  // Chart instances kept here
  let chartHour = null;
  let chartWeek = null;

  // Create charts (call after backing store synced)
  function createCharts() {
    // destroy if exist
    if (chartHour) { chartHour.destroy(); chartHour = null; }
    if (chartWeek) { chartWeek.destroy(); chartWeek = null; }

    // common options: responsive:false to avoid auto-resize loop
    const commonOpts = {
      responsive: false,
      maintainAspectRatio: false,
      plugins: {
        legend:{ position:'top', labels:{color:'#e6eef3', boxWidth:12} },
        tooltip:{ callbacks:{ label: ctx => `${ctx.dataset.label}: ${ctx.parsed.y}` } }
      },
      scales: {
        x: { stacked:true, ticks:{color:'#cbd5da'}, grid:{color:'rgba(255,255,255,0.03)'} },
        y: { stacked:true, beginAtZero:true, ticks:{color:'#cbd5da', precision:0}, grid:{color:'rgba(255,255,255,0.03)'} }
      }
    };

    chartHour = new Chart(canvasHour.getContext('2d'), {
      type: 'bar',
      data: { labels: hours.map(h=>h.label), datasets: buildDatasets(hours) },
      options: Object.assign({}, commonOpts, {
        plugins: Object.assign({}, commonOpts.plugins, {
          tooltip: { callbacks: Object.assign({}, commonOpts.plugins.tooltip.callbacks, {
            title: items => `Hour: ${items[0].label} (local)`
          }) }
        })
      })
    });

    chartWeek = new Chart(canvasWeek.getContext('2d'), {
      type: 'bar',
      data: { labels: days.map(d=>d.label), datasets: buildDatasets(days) },
      options: Object.assign({}, commonOpts, {
        plugins: Object.assign({}, commonOpts.plugins, {
          tooltip: { callbacks: Object.assign({}, commonOpts.plugins.tooltip.callbacks, {
            title: items => `Day: ${items[0].label}`
          }) }
        })
      })
    });
  }

  // initial setup + create
  function initAndCreate() {
    syncCanvasBacking(canvasHour, HOUR_CANVAS_PX);
    syncCanvasBacking(canvasWeek, WEEK_CANVAS_PX);
    createCharts();
  }

  // debounce utility
  function debounce(fn, ms=120){
    let t;
    return (...a)=>{ clearTimeout(t); t=setTimeout(()=>fn(...a), ms); };
  }

  // on resize: recompute backing store and recreate charts
  const onResize = debounce(()=>{ initAndCreate(); }, 150);
  window.addEventListener('resize', onResize);

  // first run
  initAndCreate();

})();
</script>
</body>
</html>
